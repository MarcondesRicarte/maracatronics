/*
 * *********************************************************
 * Copyright (c) 2009 - 2011, DHBW Mannheim - Tigers Mannheim
 * Project: TIGERS - Sumatra
 * Date: 09.10.2011
 * Author(s): Paul
 * *********************************************************
 */
package edu.dhbw.mannheim.tigers.sumatra.model.modules.impls.ai.metis.calculators.fieldanalysis;

import java.util.ArrayList;
import java.util.Map.Entry;

import edu.dhbw.mannheim.tigers.sumatra.model.data.frames.BaseAiFrame;
import edu.dhbw.mannheim.tigers.sumatra.model.data.frames.WorldFrame;
import edu.dhbw.mannheim.tigers.sumatra.model.data.math.GeoMath;
import edu.dhbw.mannheim.tigers.sumatra.model.data.modules.ai.TacticalField;
import edu.dhbw.mannheim.tigers.sumatra.model.data.trackedobjects.TrackedTigerBot;
import edu.dhbw.mannheim.tigers.sumatra.model.data.trackedobjects.ids.BotID;
import edu.dhbw.mannheim.tigers.sumatra.model.data.trackedobjects.ids.IBotIDMap;
import edu.dhbw.mannheim.tigers.sumatra.model.modules.impls.ai.metis.calculators.ACalculator;
import edu.dhbw.mannheim.tigers.sumatra.util.config.Configurable;


/**
 * This {@link FieldAnalyserCalc} uses the raster generated by the {@link FieldAnalyserCalc} to create a scored field
 * for
 * offensive and defensive robot positioning.
 * 
 * @author PaulB, OliverS, PhilippP
 */
public class FieldAnalyserCalc extends ACalculator
{
	
	
	// --------------------------------------------------------------------------
	// --- variables and constants ----------------------------------------------
	// --------------------------------------------------------------------------
	private final AIRectangleVector	ratedRectangles;
	
	private FieldAnaParallelMath		parallelMath;
	private FieldRasterGenerator		fieldRasterGenerator;
	@Configurable(comment = "Mode: GPU(1) or CPU(2)")
	private static int					mode	= 2;
	@Configurable(comment = "Manalobis(1)/Standard(2)")
	private static int					kind	= 2;
	private EnhancedFieldAnalyser		enhancedFieldAnalyser;
	
	
	// --------------------------------------------------------------------------
	// --- constructors ---------------------------------------------------------
	// --------------------------------------------------------------------------
	/**
	 * Create a FieldAnalyser.
	 */
	public FieldAnalyserCalc()
	{
		fieldRasterGenerator = new FieldRasterGenerator();
		ratedRectangles = new AIRectangleVector(fieldRasterGenerator);
		parallelMath = new FieldAnaParallelMath(kind, mode);
	}
	
	
	// --------------------------------------------------------------------------
	// --- methods --------------------------------------------------------------
	// --------------------------------------------------------------------------
	
	
	/**
	 * Create the initial Rectangles for foeBots and TigersBots.
	 * 
	 * @param tigerBots
	 * @param foeBots
	 */
	public void calculateRectangles(final IBotIDMap<TrackedTigerBot> tigerBots, final IBotIDMap<TrackedTigerBot> foeBots)
	{
		enhancedFieldAnalyser = new EnhancedFieldAnalyser(ratedRectangles);
		ArrayList<ArrayList<AIRectangle>> maxFoeTakenRectangles = new ArrayList<ArrayList<AIRectangle>>();
		ArrayList<ArrayList<AIRectangle>> maxTigersTakenRectangles = new ArrayList<ArrayList<AIRectangle>>();
		// List for all Quadrants
		maxFoeTakenRectangles.add(new ArrayList<AIRectangle>());
		maxFoeTakenRectangles.add(new ArrayList<AIRectangle>());
		maxFoeTakenRectangles.add(new ArrayList<AIRectangle>());
		maxFoeTakenRectangles.add(new ArrayList<AIRectangle>());
		// List for all Quadrants
		maxTigersTakenRectangles.add(new ArrayList<AIRectangle>());
		maxTigersTakenRectangles.add(new ArrayList<AIRectangle>());
		maxTigersTakenRectangles.add(new ArrayList<AIRectangle>());
		maxTigersTakenRectangles.add(new ArrayList<AIRectangle>());
		
		// codieren der Daten um sie an ParallelMath weiterzugeben
		int countTigerBots = tigerBots.size();
		int countFoeBots = foeBots.size();
		int[] botPos = new int[countFoeBots + countTigerBots];
		float[] botSpeed = new float[(countFoeBots + countTigerBots) * 2];
		int i = 0;
		for (Entry<BotID, TrackedTigerBot> bot : tigerBots)
		{
			try
			{
				botPos[i] = fieldRasterGenerator.getAnalysingIDFromPosition(bot.getValue().getPos());
				botSpeed[2 * i] = bot.getValue().getVel().x();
				botSpeed[(2 * i) + 1] = bot.getValue().getVel().y();
				i++;
			} catch (IllegalArgumentException ex)
			{
			}
		}
		
		for (Entry<BotID, TrackedTigerBot> bot : foeBots)
		{
			try
			{
				botSpeed[2 * i] = bot.getValue().getVel().x();
				botSpeed[(2 * i) + 1] = bot.getValue().getVel().y();
				botPos[i] = fieldRasterGenerator.getAnalysingIDFromPosition(bot.getValue().getPos());
				i++;
			} catch (IllegalArgumentException ex)
			{
			}
		}
		// value of the quadrants
		float quadrantNr1 = 0;
		float quadrantNr2 = 0;
		float quadrantNr3 = 0;
		float quadrantNr4 = 0;
		
		if (botPos.length > 0)
		{
			float[] rectangleValues = parallelMath.calculate(botPos, botSpeed, countTigerBots,
					FieldRasterGenerator.getAnalysingFactor() * FieldRasterGenerator.getNumberOfRows(),
					FieldRasterGenerator.getAnalysingFactor() * FieldRasterGenerator.getNumberOfColumns());
			
			for (int j = 0; j < rectangleValues.length; j++)
			{
				final AIRectangle actualRectangle = ratedRectangles.get(j);
				actualRectangle.setValue(rectangleValues[j]);
				
				// Finds out in witch quadrant the Rectangle is
				int quadrant = GeoMath.checkQuadrant(actualRectangle.getMidPoint());
				
				switch (quadrant)
				{
					case 1:
						quadrantNr1 += actualRectangle.getValue();
						break;
					case 2:
						quadrantNr2 += actualRectangle.getValue();
						break;
					case 3:
						quadrantNr3 += actualRectangle.getValue();
						break;
					case 4:
						quadrantNr4 += actualRectangle.getValue();
						break;
				}
				
				// Set the highest or lowst Value to max
				if (enhancedFieldAnalyser.getTotalMaximum() < Math.abs(actualRectangle.getValue()))
				{
					enhancedFieldAnalyser.setTotalMaximum(actualRectangle.getValue());
				}
				sortInMaximumsToQuadrants(actualRectangle, maxFoeTakenRectangles, maxTigersTakenRectangles);
			}
		}
		enhancedFieldAnalyser.setScoringOfQuadrants(quadrantNr1, quadrantNr2, quadrantNr3, quadrantNr4);
		enhancedFieldAnalyser.setMaxFoeTakenRectangleID(maxFoeTakenRectangles);
		enhancedFieldAnalyser.setMaxTigersTakenRectangleID(maxTigersTakenRectangles);
	}
	
	
	@Override
	public void doCalc(final TacticalField newTacticalField, final BaseAiFrame baseAiFrame)
	{
		WorldFrame wFrame = baseAiFrame.getWorldFrame();
		calculateRectangles(wFrame.getTigerBotsVisible(), wFrame.getFoeBots());
		newTacticalField.setEnhancedFieldAnalyser(enhancedFieldAnalyser);
	}
	
	
	// --------------------------------------------------------------------------
	// --- getter/setter --------------------------------------------------------
	// --------------------------------------------------------------------------
	
	
	/**
	 * Goes thought the list, and set the maximum to the right quadrants
	 * 
	 * @param actualRectangle
	 * @param maxTigersTakenRectangles
	 * @param maxFoeTakenRectangles
	 */
	private void sortInMaximumsToQuadrants(final AIRectangle actualRectangle,
			final ArrayList<ArrayList<AIRectangle>> maxFoeTakenRectangles,
			final ArrayList<ArrayList<AIRectangle>> maxTigersTakenRectangles)
	{
		switch (GeoMath.checkQuadrant(actualRectangle.getMidPoint()))
		{
			case 1:
			{
				ArrayList<AIRectangle> maxFoeList = maxFoeTakenRectangles.get(0);
				ArrayList<AIRectangle> maxTigersList = maxTigersTakenRectangles.get(0);
				
				isMaximum(actualRectangle, maxFoeList, maxTigersList);
				
			}
				break;
			case 2:
			{
				ArrayList<AIRectangle> maxFoeList = maxFoeTakenRectangles.get(1);
				ArrayList<AIRectangle> maxTigersList = maxTigersTakenRectangles.get(1);
				
				isMaximum(actualRectangle, maxFoeList, maxTigersList);
			}
				break;
			case 3:
			{
				ArrayList<AIRectangle> maxFoeList = maxFoeTakenRectangles.get(2);
				ArrayList<AIRectangle> maxTigersList = maxTigersTakenRectangles.get(2);
				
				isMaximum(actualRectangle, maxFoeList, maxTigersList);
			}
				break;
			case 4:
			{
				ArrayList<AIRectangle> maxFoeList = maxFoeTakenRectangles.get(3);
				ArrayList<AIRectangle> maxTigersList = maxTigersTakenRectangles.get(3);
				
				isMaximum(actualRectangle, maxFoeList, maxTigersList);
			}
				break;
			default:
				break;
		}
	}
	
	
	/**
	 * Check if is a maximum. If yes, set the maximum. If equal add to list.
	 * 
	 * @param maxTigersList
	 * @param maxFoeList
	 * @param actualRectangle
	 */
	private void isMaximum(final AIRectangle actualRectangle, final ArrayList<AIRectangle> maxFoeList,
			final ArrayList<AIRectangle> maxTigersList)
	{
		// TODO Epsilon bei gleicheit
		if ((maxFoeList.size() == 0) || (maxTigersList.size() == 0))
		{
			maxFoeList.add(actualRectangle);
			maxTigersList.add(actualRectangle);
			return;
		}
		
		if (ratedRectangles.get(maxFoeList.get(0).getRectangleID()).getValue() == actualRectangle.getValue())
		{
			maxFoeList.add(actualRectangle);
		} else if (ratedRectangles.get(maxFoeList.get(0).getRectangleID()).getValue() <= actualRectangle.getValue())
		{
			maxFoeList.clear();
			maxFoeList.add(actualRectangle);
		}
		
		if (ratedRectangles.get(maxTigersList.get(0).getRectangleID()).getValue() == actualRectangle.getValue())
		{
			maxTigersList.add(actualRectangle);
		} else if (ratedRectangles.get(maxTigersList.get(0).getRectangleID()).getValue() >= actualRectangle.getValue())
		{
			maxTigersList.clear();
			maxTigersList.add(actualRectangle);
		}
		
	}
	
	
	/**
	 * @return scored {@link AIRectangle}s within the {@link AIRectangleVector}.
	 */
	public AIRectangleVector getAnalysisRectangles()
	{
		return ratedRectangles;
	}
	
	
	@Override
	public void fallbackCalc(final TacticalField newTacticalField, final BaseAiFrame baseAiFrame)
	{
		EnhancedFieldAnalyser efa = baseAiFrame.getPrevFrame().getTacticalField().getEnhancedFieldAnalyser();
		if (efa != null)
		{
			newTacticalField.setEnhancedFieldAnalyser(efa);
		} else
		{
			newTacticalField.setEnhancedFieldAnalyser(new EnhancedFieldAnalyser(
					new AIRectangleVector(fieldRasterGenerator)));
		}
	}
}
